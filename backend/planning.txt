class Player {
    readonly socketId: string
    readonly username: string
    hand: Card[]
    uno: boolean

    getHand(): Card[]
    addToHand(cards: Card[]): void

    removeCards(cardIds: string[]): Card[]

    setIsUno(isUno: boolean): void
    isUno(): boolean

    getCardsToPlay(cardIds: string[]): Card[]
}

class Card {
    readonly id: string
    readonly name: string
    readonly color: CardColor
    readonly value: CardValue
}

class GameBoard {
    readonly id: string
    discardPile: Card[]
    drawPile: Card[] // This is a stack
    currentTopCard: Card | null
    enforcedColor: CardColor | null

    getDiscardPile(): Card[]
    pushToDiscardPile(cards: Card[]): void
    clearDiscardPile(): Card[] // This is used to clean the discardPile and add to drawPile

    getDrawPile(): Card[]
    pushToDrawPile(cards: Card[]): void
    shuffleDrawPile(): void
    popFromDrawPile(amount: number): Card[]

    setCurrentTopCard(card: Card):void
    getCurrentTopCard(): Card

    setEnforcedColor(color: CardColor): void
    getEnforcedColor(): CardColor

    getCardType(card: Card): string
    processPattern(cards: Card[]): nextTurnEvents
}

class GameRoom {
    readonly id: string // ALSO USES FOR NETWORK ID
    readonly name: string
    readonly ownerId: string | player.id
    readonly maxPlayers: number
    gameBoard: GameBoard

    // SET AS DEFAULT VALUE
    started: boolean
    currentPlayers: Player[]
    playerOrder: Player[]
    direction: number
    currentPlayerIndex: number

    isFull(): boolean
    setHasStarted(started: boolean): void
    hasStarted(): boolean
    getGameBoard(): GameBoard
    
    getCurrentPlayers(): Player[]
    addCurrentPlayer(player: Player): void
    removeCurrentPlayer(playerSocketId: string): Player

    setPlayerOrder(playerOrder: Player[]): void
    getPlayerOrder(): Player[]
    removeFromPlayerOrder(playerSocketId: string): Player
    setDirection(direction: number): void
    getDirection(): number
    setCurrentPlayerIndex(index: number): void
    getCurrentPlayerIndex(): number
    getPlayerFromOrder(): Player
}

// @Injectable - Singleton
class GameGateway {
    game: GameService

    ON SERVER CONNECTION
        - Establish websocket connection (/)

    1. Player create a room in the namespace:
    - expects: name, maxPlayers, playerSocketId 
        - On "create-room" event:
            - Initialize Player based on their socket 
            - Create logical GameRoom 
            - Create a network room
            - Join current player to network room
            - Add them to GameRoom currentPlayer
            - Add GameRoom to game.rooms

    2. Players join created room:
    - expects: roomId, playerSocketId
        - On "join-room" event:
            If exists room id in rooms
            If room is not full
            If room hasnt started
                - Join them to network room
                - Add them to GameRoom currentPlayer
            Else
                Dont connect and emit error

    3. Players leave created room:
    - expects: roomId, playerSocketId
        - On "leave-room" or "disconnect" events:
            - Disconnect them from network room
            - Remove them from currentPlayers

    THIS IS TO BE ADDED AS CHECK
    4. If theres no Player in a room
        - Remove network room
        - Remove empty room
}

// @Injectable - Singleton
class GameService {
    rooms: Map<GameRoom> roomId, room

    // STARTING THE GAME: 
    - "start-game" event 
    - expects: networkRoomId, playerSocketId from the client
    - get room, player from ids
    startGame(room: GameRoom, player: Player) 
        If player.socketId === room.ownerId AND room.currentPlayers > 1:
            Set room.started = true
        Else:
            Throws an error
        Set playerOrder
        Get the cards
        Push cards to drawPile
        shuffleDrawPile
        Push 7 cards to each player hand FROM drawPile
        Start discardPile with 1 top card from drawPile (ONLY ALLOW NUMBER CARDS)
        Set currentTopCard
    
    // GAMEPLAY: 
    // THINK IN TERMS OF SOCKET EVENTS, REACT TO EVENTS THAT WAS THROWN
    - "draw-cards" event
    - expects: networkRoomId, playerSocketId, amount from the client
    - get room, player from ids
    drawCards(room: GameRoom, player: Player, amount: number): void
        if player !== room.getPlayerFromOrder:
            throw an error
        Player draws a card from drawPile:
            If amount > drawPile:
                clearDiscardPile
                pushToDrawPile
                shuffleDrawPile
            Push card from drawPile to player's hand

    - "uno" event 
    - expects: networkRoomId, playerSocketId from the client
    - get room, player from ids
    uno(room: GameRoom, player: Player): void
        if player !== room.getPlayerFromOrder:
            throw an error
        Get player's hand:
        If player's cards === 2:
            Set player.uno = true
        Else:
            throw an error

    - "play-cards" event
    - expects: networkRoomId, playerSocketId, cardIds from the client
    - get room, player, cardsToPlay from ids
    playCards(room: GameRoom, player: Player, cardsToPlay: Card[]): nextTurnEvents
        if player !== room.getPlayerFromOrder:
            throw an error
        If cardsToPlay is a valid pattern starting with top card:
            Remove cards from player's hand
            Push cards to discardPile
            Set currentTopCard
        Else: 
            Throws an error
    Update current room turn event
    Update currentPlayerIndex

    Call this after "play-cards"
    processTurn(room: GameRoom): void 
        Current player is determined by currentPlayerIndex of playerOrder 
        currentPlayer = room.getPlayerFromOrder()

        Determines current turn events based on turnEvents of room

        Dispatch "new-turn" event with data for clients
}   

