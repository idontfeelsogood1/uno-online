class Player {
    readonly socketId: string
    readonly username: string
    hand: Card[]
    uno: boolean

    getHand(): Card[]
    addToHand(cards: Card[]): void

    removeCards(cardIds: string[]): Card[]

    setIsUno(isUno: boolean): void
    isUno(): boolean

    getCardsToPlay(cardIds: string[]): Card[]
}

class Card {
    readonly id: string
    readonly name: string
    readonly color: CardColor
    readonly value: CardValue
}

class GameBoard {
    readonly id: string
    discardPile: Card[]
    drawPile: Card[] // This is a stack
    currentTopCard: Card | null
    enforcedColor: CardColor | null

    getDiscardPile(): Card[]
    pushToDiscardPile(cards: Card[]): void
    clearDiscardPile(): Card[] // This is used to clean the discardPile and add to drawPile

    getDrawPile(): Card[]
    pushToDrawPile(cards: Card[]): void
    shuffleDrawPile(): void
    popFromDrawPile(amount: number): Card[]

    setCurrentTopCard(card: Card):void
    getCurrentTopCard(): Card

    setEnforcedColor(color: CardColor): void
    getEnforcedColor(): CardColor

    getCardType(card: Card): string
    processPattern(cards: Card[]): nextTurnEvents
}

class GameRoom {
    readonly id: string // ALSO USES FOR NETWORK ID
    readonly name: string
    readonly ownerId: string | player.id
    readonly maxPlayers: number
    gameBoard: GameBoard

    // SET AS DEFAULT VALUE
    started: boolean
    currentPlayers: Player[]
    playerOrder: Player[]
    direction: number
    currentPlayerIndex: number

    isFull(): boolean
    setHasStarted(started: boolean): void
    hasStarted(): boolean
    getGameBoard(): GameBoard
    
    getCurrentPlayers(): Player[]
    addCurrentPlayer(player: Player): void
    removeCurrentPlayer(playerSocketId: string): Player

    setPlayerOrder(playerOrder: Player[]): void
    getPlayerOrder(): Player[]
    removeFromPlayerOrder(playerSocketId: string): Player
    setDirection(direction: number): void
    getDirection(): number
    setCurrentPlayerIndex(index: number): void
    getCurrentPlayerIndex(): number
    getPlayerFromOrder(): Player
}

// @Injectable - Singleton
class GameGateway {
    game: GameService

    ON SERVER CONNECTION
        - Establish websocket connection (/)

    1. Player create a room in the namespace:
    - expects: name, maxPlayers, playerSocketId 
        - On "create-room" event:
            - Initialize Player based on their socket 
            - Create logical GameRoom 
            - Create a network room
            - Join current player to network room
            - Add them to GameRoom currentPlayer
            - Add GameRoom to game.rooms

    2. Players join created room:
    - expects: roomId, playerSocketId
        - On "join-room" event:
            If exists room id in rooms
            If room is not full
            If room hasnt started
                - Join them to network room
                - Add them to GameRoom currentPlayer
            Else
                Dont connect and emit error

    3. Players leave created room:
    - expects: roomId, playerSocketId
        - On "leave-room" or "disconnect" events:
            - Disconnect them from network room
            - Remove them from currentPlayers

    THIS IS TO BE ADDED AS CHECK
    4. If theres no Player in a room
        - Remove network room
        - Remove empty room
}

// @Injectable - Singleton
class GameService {
    rooms: Map<GameRoom> roomId, room

    // METHODS SHOULD THROW ERRORS TO SIGNAL GameGateway TO EMIT SOME EVENTS FOR THE CLIENT

    // STARTING THE GAME: 
    - "start-game" event 
    - expects: networkRoomId, playerSocketId from the client
    - get room, player from ids
    startGame(room: GameRoom, player: Player): void
        If player.socketId === room.ownerId AND room.currentPlayers > 1:
            Set room.started = true
        Else:
            Throws an error
        Set playerOrder
        Get the cards
        Push cards to drawPile
        shuffleDrawPile
        Push 7 cards to each player hand FROM drawPile
        Start discardPile with 1 top card from drawPile (ONLY ALLOW NUMBER CARDS)
        Set currentTopCard
        

    // GAMEPLAY: 
    // THINK IN TERMS OF SOCKET EVENTS, REACT TO EVENTS THAT WAS THROWN
    // SEND BACK A NEW STATE FOR EVERY EVENTS

    - "draw-cards" event
    - expects: roomNetworkId, playerSocketId, amount from the client
    - get room, player from ids
    - check if its player's turn
    drawCards(room: GameRoom, player: Player, amount: number): void
        Player draws a card from drawPile:
            If amount > drawPile:
                clearDiscardPile
                pushToDrawPile
                shuffleDrawPile
                throw an error
            Push card from drawPile to player's hand
    Set player.uno to false after they draw the cards

    - "uno" event 
    - expects: roomNetworkId, playerSocketId, cardsId from the client
    - get room, player, from ids
    - check if its player's turn
    uno(room: GameRoom, player: Player, cardsId: string[]): void
        Get player's hand:
        If player's cards - cardsToPlay === 0 or 1:
            Set player.uno = true
        Else:
            throw an error

    // THE PLAYER PLAYS A HAND, THEN PROCESS THE TURN EVENTS 
    - "play-cards" event
    - expects: networkRoomId, playerSocketId, cardIds from the client
    - get room, player from ids
    - check if its player's turn
    playCards(room: GameRoom, player: Player, cardIds: string[]): void
        If cardsToPlay is a valid pattern starting with top card:
            Remove cards from player's hand
            Push cards to discardPile
            Set turnEvents
            Set currentTopCard
        Else: 
            Throws an error
    Set player.uno to false when playCards throw an error

    // PROCESS THE EVENTS FOR THE CURRENT PLAYER AND THE NEXT PLAYER
    processTurn(room: GameRoom): void 
        Current player is determined by currentPlayerIndex of playerOrder 
        currentPlayer = room.getPlayerFromOrder()

        If player.hand === 0 OR 1 AND player.uno === false:
            Pop 2 cards from drawPile
            Push the cards to player's hand

        If currentTopCard === 'WILD': 
        - Dispatch event "choose-enforce-color" for the currentPlayer
        - Wait for response from client
        - Set enforcedColor
        // currentPlayer's turn end

        // Next player turn
        Determines turn events based on turnEvents of GameBoard
        updateDirection(reverse_amount: number)
        updateCurrentPlayerIndex(skip_amount?: number, direction: number)
        If draw_two:
            Pop cards from drawPile
            Push cards to player's hand
        If wild_draw_four:
            Pop cards from drawPile
            Push cards to player's hand  
    Set player.uno to false
}   

