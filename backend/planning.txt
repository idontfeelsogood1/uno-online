class Player {
    readonly socketId: string
    readonly username: string
    hand: Card[]
    uno: boolean

    getHand(): Card[]
    addToHand(cards: Card[]): void

    removeCards(cardIds: string[]): Card[]

    setIsUno(isUno: boolean): void
    isUno(): boolean

    getCardsToPlay(cardIds: string[]): Card[]
}

class Card {
    readonly id: string
    readonly name: string
    readonly color: CardColor
    readonly value: CardValue
}

class GameBoard {
    readonly id: string
    discardPile: Card[]
    drawPile: Card[] // This is a stack
    currentTopCard: Card | null
    enforcedColor: CardColor | null

    getDiscardPile(): Card[]
    pushToDiscardPile(cards: Card[]): void
    clearDiscardPile(): Card[] // This is used to clean the discardPile and add to drawPile

    getDrawPile(): Card[]
    pushToDrawPile(cards: Card[]): void
    shuffleDrawPile(): void
    popFromDrawPile(amount: number): Card[]

    setCurrentTopCard(card: Card):void
    getCurrentTopCard(): Card

    setEnforcedColor(color: CardColor): void
    getEnforcedColor(): CardColor

    getCardType(card: Card): string
    processPattern(cards: Card[]): nextTurnEvents
}

class GameRoom {
    readonly id: string // ALSO USES FOR NETWORK ID
    readonly name: string
    readonly ownerId: string | player.id
    readonly maxPlayers: number
    gameBoard: GameBoard

    // SET AS DEFAULT VALUE
    started: boolean
    currentPlayers: Player[]
    playerOrder: Player[]
    direction: number
    currentPlayerIndex: number

    isFull(): boolean
    setHasStarted(started: boolean): void
    hasStarted(): boolean
    getGameBoard(): GameBoard
    
    getCurrentPlayers(): Player[]
    addCurrentPlayer(player: Player): void
    removeCurrentPlayer(playerSocketId: string): Player

    setPlayerOrder(playerOrder: Player[]): void
    getPlayerOrder(): Player[]
    removeFromPlayerOrder(playerSocketId: string): Player
    setDirection(direction: number): void
    getDirection(): number
    setCurrentPlayerIndex(index: number): void
    getCurrentPlayerIndex(): number
    getPlayerFromOrder(): Player
}

// @Injectable - Singleton
class GameGateway {
    game: GameService

    ON SERVER CONNECTION
        - Establish websocket connection (/)

    1. Player create a room in the namespace: 
        - On "create-room" event:
            - Initialize Player based on their socket 
            - Create logical GameRoom 
            - Create a network room
            - Join current player to network room
            - Add them to GameRoom currentPlayer
            - Add GameRoom to rooms

    2. Players join created room:
        - On "join-room" event:
            If exists room id in rooms
            If room is not full
            If room hasnt started
                - Join them to network room
                - Add them to GameRoom currentPlayer
            Else
                Dont connect and emit error

    3. Players leave created room:
        - On "leave-room" event:
            - Disconnect them from network room
            - Remove them from currentPlayers

    4. If theres no Player in a room
        - Remove network room
        - Remove empty room
}

// @Injectable - Singleton
class GameService {
    rooms: Map<GameRoom> roomId, room

    createPlayer(
        socketId: string,
        username: string
    ): Player
    addPlayerToRoom(roomId: string, player: Player): void
    getPlayerOfRoom(roomId: string, playerSocketId: string): Player
    removePlayerFromRoom(roomId: string, playerSocketId: string): Player

    createRoom(
        id: string,
        name: string,
        ownerId: string,
        maxPlayer: number,
        gameBoard: new GameBoard(id: string),
    ): GameRoom
    addRoom(room: GameRoom): void
    getRoom(roomId: string): GameRoom
    removeRoom(roomId: string): GameRoom

    // STARTING THE GAME: startGame() throws error if error
        If player.socketId === room.ownerId AND room.currentPlayers > 1:
            Set room.started = true
        Set playerOrder
        Get the cards
        Push cards to drawPile
        shuffleDrawPile
        Push 7 cards to each player hand FROM drawPile
        Start discardPile with 1 top card from drawPile (ONLY ALLOW NUMBER CARDS)
        Set currentTopCard
    
    // GAMEPLAY: processGame(player: Player)
        Ordered by playerOrder

        Get player's hand:
        If player's cards === 2:
            Allow player to uno

        Player get cardsToPlay:
        If cardsToPlay is a valid pattern starting with top card:
            Remove cards from player's hand
            Push cards to discardPile
            Set currentTopCard
            Set next turn events of action cards based on return obj of processPattern
            Move on to next player
        Else: 
            Throws an error

        Get player's hand:
        If player's cards === 1 AND player has not uno:
            Push 2 cards to player's hand from drawPile

        If player's cards === 0:
            Wins the round
            Announce winner
            Do cleanup operations

        Player draws a card from drawPile:
            If amount > drawPile:
                clearDiscardPile
                pushToDrawPile
                shuffleDrawPile
            Push card from drawPile to player's hand
}   

public processPattern(cards: Card[], enforcedColor: CardColor): nextTurnEvents {
    // Initialize pseudo top card with currentTopCard
    // Start from the pseudo top card
    // First card must match pseudo top card color or value (Except for wilds)
    // If wild AND (firstCard.color === enforcedColor || firstCardType === 'WIlD'):
      // Update pseudo top card with first card in cards
    // Else :
      // Throws an error

    // Only 1 card type per move (currType === topType)
      // If currType !== topType:
        // throws an error

    // For number type:
      // Must be correct stacking pattern (1, 1, 2, 2, 3, 3)
      // If:
        // currCard.color === topCard.color AND currCard.value - topCard.value must be off by 0 or 1 (same color matching pattern)
        // OR
        // currCard.color !== topCard.color AND currCard.value === topCard.value (different color same value)
          // Update pseudo top card
      // Else:
          // Throws an error 

    // For action type AND wild type:
      // If currCard.value === topCard.value:
        // Update pseudo top card
      // Else:
        // Throws an error 
  }